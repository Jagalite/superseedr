name: Rust

on:
  push:
    branches: [ "main" ]
    tags:
      - 'v*'
  pull_request:
    branches: [ "main" ]

permissions:
  contents: write

env:
  CARGO_TERM_COLOR: always
  APP_NAME: superseedr

jobs:
  # This job runs first, reads the version from Cargo.toml,
  # and provides it as an output to all other jobs.
  get_version:
    name: Get Package Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.read_version.outputs.version }}
    steps:
      - uses: actions/checkout@v5
      - name: Read version from Cargo.toml
        id: read_version
        run: |
          # Use a robust grep/sed to extract the version
          VERSION=$(grep '^version = ' Cargo.toml | sed -E 's/version = "([^"]+)"/\1/')
          if [ -z "$VERSION" ]; then
            echo "::error:: Could not find version in Cargo.toml"
            exit 1
          fi
          echo "Found version: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

  build_linux:
    name: Build & Test (Linux)
    runs-on: ubuntu-latest
    needs: get_version # Wait for the get_version job
    env:
      VERSION: ${{ needs.get_version.outputs.version }} # Get version from 'get_version' job
    steps:
    - uses: actions/checkout@v5

    - name: Install Dependencies
      run: |
        sudo apt-get update

    - name: Build
      run: cargo build --verbose --release
    - name: Run tests
      run: cargo test --verbose

    # --- Bundling Steps (Only on Tags) ---
    - name: Install cargo-bundle
      if: startsWith(github.ref, 'refs/tags/')
      run: cargo install cargo-bundle

    - name: Create Staging Directory
      if: startsWith(github.ref, 'refs/tags/')
      run: mkdir staging

    - name: Build Private Debian Package
      if: startsWith(github.ref, 'refs/tags/')
      run: cargo bundle --release --no-default-features --format deb

    - name: Move Renamed Private Debian Package
      if: startsWith(github.ref, 'refs/tags/')
      run: |
        # Find the .deb file
        DEB_FILE=$(find target/release/bundle/deb -name '*.deb')
        if [ -z "$DEB_FILE" ]; then
          echo "::error:: No .deb file found after private bundle."
          exit 1
        fi
        
        # Rename using the explicit version from Cargo.toml
        echo "Moving $DEB_FILE to staging/${APP_NAME}-private_${VERSION}_amd64.deb"
        mv "$DEB_FILE" "staging/${APP_NAME}-private_${VERSION}_amd64.deb"

    - name: Build Normal Debian Package
      if: startsWith(github.ref, 'refs/tags/')
      run: cargo bundle --release --format deb

    - name: Move Normal Debian Package to Staging
      if: startsWith(github.ref, 'refs/tags/')
      run: |
        DEB_FILE=$(find target/release/bundle/deb -name '*.deb')
        if [ -z "$DEB_FILE" ]; then
          echo "::error:: No .deb file found after normal bundle."
          exit 1
        fi
        # Rename using the explicit version from Cargo.toml
        echo "Moving $DEB_FILE to staging/${APP_NAME}_${VERSION}_amd64.deb"
        mv "$DEB_FILE" "staging/${APP_NAME}_${VERSION}_amd64.deb"

    - name: Upload Debian Package Artifacts
      if: startsWith(github.ref, 'refs/tags/')
      uses: actions/upload-artifact@v4
      with:
        # Use the version in the artifact name for clarity
        name: superseedr-linux-amd64-debs-v${{ env.VERSION }}
        path: staging/*.deb

  bundle_macos:
    name: Build macOS Universal PKG (${{ matrix.suffix }})
    if: startsWith(github.ref, 'refs/tags/')
    runs-on: macos-latest
    needs: get_version # Wait for the get_version job
    env:
      KEYCHAIN_NAME: build.keychain
      VERSION: ${{ needs.get_version.outputs.version }} # Get version from 'get_version' job
    strategy:
      matrix:
        include:
          - suffix: "normal"
            flags: ""
          - suffix: "private"
            flags: --no-default-features
    steps:
    - uses: actions/checkout@v5 

    - name: Install Rust Apple Targets
      run: |
        rustup target add aarch64-apple-darwin
        rustup target add x86_64-apple-darwin

    - name: Setup macOS Keychain and Certificate
      # ... (no changes in this step)
      id: setup_keychain
      env:
        APPLE_INSTALLER_CERT_P12_BASE64: ${{ secrets.APPLE_INSTALLER_CERT_P12_BASE64 }}
        APPLE_INSTALLER_CERT_PASSWORD: ${{ secrets.APPLE_INSTALLER_CERT_PASSWORD }}
      run: |
        security create-keychain -p "$RUNNER_TEMP" "$KEYCHAIN_NAME"
        security list-keychains -s "$KEYCHAIN_NAME"
        security default-keychain -s "$KEYCHAIN_NAME"
        security unlock-keychain -p "$RUNNER_TEMP" "$KEYCHAIN_NAME"
        echo $APPLE_INSTALLER_CERT_P12_BASE64 | base64 --decode > certificate.p12
        security import certificate.p12 -k "$KEYCHAIN_NAME" -P "$APPLE_INSTALLER_CERT_PASSWORD" -T /usr/bin/codesign -T /usr/bin/productsign
        rm certificate.p12
        security set-key-partition-list -S apple-tool:,apple: -s -k "$RUNNER_TEMP" "$KEYCHAIN_NAME"
        echo "Waiting for keychain to settle..."
        sleep 2
        CERT_CN=$(security find-identity -v "$KEYCHAIN_NAME" | grep "Developer ID Installer" | head -n 1 | sed -E 's/.*"([^"]+)".*/\1/')
        if [ -z "$CERT_CN" ]; then
          echo "::error:: No valid codesigning identity found in keychain."
          security find-identity -v "$KEYCHAIN_NAME"
          exit 1
        fi
        echo "Using certificate: $CERT_CN"
        echo "CERT_NAME=$CERT_CN" >> $GITHUB_ENV
    
    - name: Execute Custom macOS Build Script
      id: build_pkg
      run: |
        SCRIPT_PATH="build_scripts/build_osx_universal_pkg.sh"
        chmod +x "$SCRIPT_PATH"
        
        set -o pipefail
        
        # --- CHANGED LINE ---
        # Pass the explicit version from Cargo.toml (e.g., "0.9.9q")
        # instead of the git tag (e.g., "v0.9.9q").
        # Your script will use this to name the .pkg file.
        "$SCRIPT_PATH" \
          ${{ env.VERSION }} \
          ${{ matrix.suffix }} \
          "${{ env.CERT_NAME }}" \
          ${{ matrix.flags }} \
          2>&1 | tee build_log.txt
        
        PKG_PATH=$(grep 'PKG_PATH=' build_log.txt | head -n 1 | sed -n 's/.*PKG_PATH=\(.*\)/\1/p' | tr -d '[:space:]')
        
        if [ -z "$PKG_PATH" ]; then
          echo "::error::Build script finished, but 'PKG_PATH=' was not found in the log."
          exit 1
        fi
        
        echo "PKG_PATH found: $PKG_PATH"
        echo "pkg_path=$PKG_PATH" >> $GITHUB_OUTPUT

    - name: Notarize and Staple PKG
      # ... (no changes in this step)
      id: notarize
      env:
        APPLE_NOTARY_USERNAME: ${{ secrets.APPLE_NOTARY_USERNAME }}
        APPLE_NOTARY_PASSWORD: ${{ secrets.APPLE_NOTARY_PASSWORD }}
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      run: |
        PKG_FILE_PATH="${{ steps.build_pkg.outputs.pkg_path }}"
        echo "Submitting $PKG_FILE_PATH for notarization..."
        xcrun notarytool submit "$PKG_FILE_PATH" \
          --apple-id "$APPLE_NOTARY_USERNAME" \
          --password "$APPLE_NOTARY_PASSWORD" \
          --team-id "$APPLE_TEAM_ID" \
          --wait
        echo "Notarization successful. Stapling ticket..."
        xcrun stapler staple "$PKG_FILE_PATH"

    - name: Cleanup Keychain
      # ... (no changes in this step)
      if: always()
      run: |
        security delete-keychain "$KEYCHAIN_NAME"

    - name: Upload macOS PKG Artifact
      uses: actions/upload-artifact@v4
      with:
        # Use the version in the artifact name for clarity
        name: superseedr-macos-${{ matrix.suffix }}-universal-v${{ env.VERSION }}
        path: ${{ steps.build_pkg.outputs.pkg_path }}
        
  build_windows:
    name: Build Windows MSI (${{ matrix.suffix }})
    if: startsWith(github.ref, 'refs/tags/')
    runs-on: windows-latest
    needs: get_version # Wait for the get_version job
    env:
      VERSION: ${{ needs.get_version.outputs.version }} # Get version from 'get_version' job
    strategy:
      matrix:
        include:
          - suffix: "normal"
            flags: ""
          - suffix: "private"
            flags: "--no-default-features"
    steps:
    - uses: actions/checkout@v5
    - name: Install Rust MSVC Target
      run: rustup target add x86_64-pc-windows-msvc
    - name: Install WiX Toolset v3
      run: choco install wixtoolset
    - name: Install cargo-wix
      run: cargo install cargo-wix
      
    - name: Build MSI Installer (${{ matrix.suffix }})
      # ... (no changes in this step)
      id: build_msi
      run: |
        if ("${{ matrix.flags }}" -eq "") {
          echo "Running: cargo wix"
          cargo wix
        } else {
          echo "Running: cargo build --release ${{ matrix.flags }}"
          cargo build --release ${{ matrix.flags }}
          echo "Running: cargo wix --no-build"
          cargo wix --no-build
        }
        $MSI_FILE = Get-ChildItem -Path "target/wix" -Filter "*.msi" | Select-Object -First 1
        if ($null -eq $MSI_FILE) { echo "::error:: No .msi file found"; exit 1; }
        echo "msi_path=$($MSI_FILE.FullName)" >> $env:GITHUB_OUTPUT

    - name: Sign MSI Installer (if secret is present)
      # ... (no changes in this step)
      if: env.WINDOWS_CERT_P12_BASE64 != ''
      id: sign_msi
      env:
        WINDOWS_CERT_P12_BASE64: ${{ secrets.WINDOWS_CERT_P12_BASE64 }}
        WINDOWS_CERT_PASSWORD: ${{ secrets.WINDOWS_CERT_PASSWORD }}
      shell: pwsh
      run: |
        [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($env:WINDOWS_CERT_P12_BASE64)) | Out-File -FilePath windows.pfx -Encoding OEM
        $MSI_PATH = "${{ steps.build_msi.outputs.msi_path }}"
        echo "Signing $MSI_PATH..."
        $SIGNTOOL_PATH = (Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits\10\bin" -Filter "signtool.exe" -Recurse | Sort-Object VersionInfo -Descending | Select-Object -First 1).FullName
        if ($null -eq $SIGNTOOL_PATH) {
          echo "::error:: signtool.exe not found."
          exit 1
        }
        echo "Using signtool at $SIGNTOOL_PATH"
        & $SIGNTOOL_PATH sign /f "windows.pfx" /p $env:WINDOWS_CERT_PASSWORD /tr http://timestamp.digicert.com /td SHA256 $MSI_PATH
        Remove-Item windows.pfx

    - name: Stage MSI
      shell: pwsh
      run: |
        # --- CHANGED BLOCK ---
        # We no longer need to read Cargo.toml.
        # We get the $VERSION directly from the env var set by the 'needs' context.
        $VERSION = $env:VERSION
        $MSI_FILE_PATH = "${{ steps.build_msi.outputs.msi_path }}"
        
        $SUFFIX = "${{ matrix.suffix }}"
        if ($SUFFIX -eq "normal") {
            $MSI_NAME = "${{ env.APP_NAME }}_${VERSION}_x64_en-US.msi"
        } else {
            $MSI_NAME = "${{ env.APP_NAME }}-${SUFFIX}_${VERSION}_x64_en-US.msi"
        }
        mkdir staging
        $DEST_PATH = "staging/$MSI_NAME"
        echo "Moving $MSI_FILE_PATH to $DEST_PATH"
        mv $MSI_FILE_PATH $DEST_PATH
        
        echo "final_msi_name=$MSI_NAME" >> $env:GITHUB_OUTPUT

    - name: Upload Windows MSI Artifact
      uses: actions/upload-artifact@v4
      with:
        # Use the version in the artifact name for clarity
        name: superseedr-windows-${{ matrix.suffix }}-v${{ env.VERSION }}
        path: staging/*.msi

  release:
    name: Create GitHub Release
    if: startsWith(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    # This job now 'needs' get_version in addition to the build jobs
    needs: [get_version, build_linux, bundle_macos, build_windows]
    steps:
      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/

      - name: Set Release Version
        # --- CHANGED STEP ---
        # Get the version from the 'get_version' job output.
        env:
          VERSION: ${{ needs.get_version.outputs.version }}
        run: echo "RELEASE_VERSION=$VERSION" >> $GITHUB_ENV
      
      - name: Create Release and Upload Artifacts
        uses: softprops/action-gh-release@v2
        with:
          # This still uses the git tag for the Release Title (e.g., "v0.9.9q")
          name: ${{ github.ref_name }}
          # The body now uses the Cargo.toml version (RELEASE_VERSION) for filenames
          # and the git tag (github.ref_name) for the download URL.
          # This is perfect, as long as they match (e.g., 0.9.9q and v0.9.9q).
          body: |
            ## Standard Builds (Recommended)
            * **macOS Universal:** [superseedr-${{ env.RELEASE_VERSION }}-universal-macos.pkg](https://github.com/Jagalite/superseedr/releases/download/${{ github.ref_name }}/superseedr-${{ env.RELEASE_VERSION }}-universal-macos.pkg)
            * **Linux (Debian):** [superseedr_${{ env.RELEASE_VERSION }}_amd64.deb](https://github.com/Jagalite/superseedr/releases/download/${{ github.ref_name }}/superseedr_${{ env.RELEASE_VERSION }}_amd64.deb)
            * **Windows (MSI):** [superseedr_${{ env.RELEASE_VERSION }}_x64_en-US.msi](https://github.com/Jagalite/superseedr/releases/download/${{ github.ref_name }}/superseedr_${{ env.RELEASE_VERSION }}_x64_en-US.msi)
            ---
            ## Private Builds (Advanced)
            These builds do not contain PEX or DHT in the final binary. Not recommended for normal users unless you have privacy requirements.
            
            * **macOS Universal:** [superseedr-${{ env.RELEASE_VERSION }}-private-universal-macos.pkg](https://github.com/Jagalite/superseedr/releases/download/${{ github.ref_name }}/superseedr-${{ env.RELEASE_VERSION }}-private-universal-macos.pkg)
            * **Linux (Debian):** [superseedr-private_${{ env.RELEASE_VERSION }}_amd64.deb](https://github.com/Jagalite/superseedr/releases/download/${{ github.ref_name }}/superseedr-private_${{ env.RELEASE_VERSION }}_amd64.deb)
            * **Windows (MSI):** [superseedr-private_${{ env.RELEASE_VERSION }}_x64_en-US.msi](https://github.com/Jagalite/superseedr/releases/download/${{ github.ref_name }}/superseedr-private_${{ env.RELEASE_VERSION }}_x64_en-US.msi)
          # --- CHANGED GLOBS ---
          # The glob patterns now use the version variable to find the
          # correctly-named artifacts from the build jobs.
          files: |
            artifacts/superseedr-linux-amd64-debs-v${{ env.RELEASE_VERSION }}/*.deb
            artifacts/superseedr-macos-*-universal-v${{ env.RELEASE_VERSION }}/*.pkg
            artifacts/superseedr-windows-*-v${{ env.RELEASE_VERSION }}/*.msi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
