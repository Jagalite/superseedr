name: Rust

on:
  push:
    branches: [ "main" ]
    tags:
      - 'v*'
  pull_request:
    branches: [ "main" ]

permissions:
  contents: write

env:
  CARGO_TERM_COLOR: always
  APP_NAME: superseedr

jobs:
  build_linux:
    name: Build & Test (Linux)
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v5

    - name: Install Dependencies
      run: |
        sudo apt-get update

    - name: Build
      run: cargo build --verbose --release
    - name: Run tests
      run: cargo test --verbose

    # --- Bundling Steps (Only on Tags) ---
    - name: Install cargo-bundle
      if: startsWith(github.ref, 'refs/tags/')
      run: cargo install cargo-bundle

    - name: Create Staging Directory
      if: startsWith(github.ref, 'refs/tags/')
      run: mkdir staging

    - name: Build Private Debian Package
      if: startsWith(github.ref, 'refs/tags/')
      run: cargo bundle --release --no-default-features --format deb

    - name: Move Renamed Private Debian Package
      if: startsWith(github.ref, 'refs/tags/')
      run: |
        DEB_FILE=$(find target/release/bundle/deb -name '*.deb')
        if [ -z "$DEB_FILE" ]; then
          echo "::error:: No .deb file found after private bundle."
          exit 1
        fi
        VERSION=$(basename "$DEB_FILE" | sed -n "s/${APP_NAME}_\(.*\)_amd64.deb/\1/p")
        echo "Moving $DEB_FILE to staging/${APP_NAME}-private_${VERSION}_amd64.deb"
        mv "$DEB_FILE" "staging/${APP_NAME}-private_${VERSION}_amd64.deb"

    - name: Build Normal Debian Package
      if: startsWith(github.ref, 'refs/tags/')
      run: cargo bundle --release --format deb

    - name: Move Normal Debian Package to Staging
      if: startsWith(github.ref, 'refs/tags/')
      run: |
        DEB_FILE=$(find target/release/bundle/deb -name '*.deb')
        if [ -z "$DEB_FILE" ]; then
          echo "::error:: No .deb file found after normal bundle."
          exit 1
        fi
        echo "Moving $DEB_FILE to staging/"
        mv "$DEB_FILE" staging/

    - name: Upload Debian Package Artifacts
      if: startsWith(github.ref, 'refs/tags/')
      uses: actions/upload-artifact@v4
      with:
        name: superseedr-linux-amd64-debs-${{ github.ref_name }}
        path: staging/*.deb

  bundle_macos:
    name: Build macOS Universal PKG (${{ matrix.suffix }})
    if: startsWith(github.ref, 'refs/tags/')
    runs-on: macos-latest
    env:
      KEYCHAIN_NAME: build.keychain
    strategy:
      matrix:
        include:
          - suffix: "normal"
            flags: ""
          - suffix: "private"
            flags: --no-default-features
    steps:
    - uses: actions/checkout@v5 

    - name: Install Rust Apple Targets
      run: |
        rustup target add aarch64-apple-darwin
        rustup target add x86_64-apple-darwin

    - name: Setup macOS Keychain and Certificate
      id: setup_keychain
      env:
        APPLE_INSTALLER_CERT_P12_BASE64: ${{ secrets.APPLE_INSTALLER_CERT_P12_BASE64 }}
        APPLE_INSTALLER_CERT_PASSWORD: ${{ secrets.APPLE_INSTALLER_CERT_PASSWORD }}
      run: |
        # Create a new keychain
        security create-keychain -p "$RUNNER_TEMP" "$KEYCHAIN_NAME"
        security list-keychains -s "$KEYCHAIN_NAME"
        security default-keychain -s "$KEYCHAIN_NAME"
        security unlock-keychain -p "$RUNNER_TEMP" "$KEYCHAIN_NAME"
        
        # Decode and import the .p12
        echo $APPLE_INSTALLER_CERT_P12_BASE64 | base64 --decode > certificate.p12
        security import certificate.p12 -k "$KEYCHAIN_NAME" -P "$APPLE_INSTALLER_CERT_PASSWORD" -T /usr/bin/codesign -T /usr/bin/productsign
        rm certificate.p12
        
        # Set keychain to allow signing
        security set-key-partition-list -S apple-tool:,apple: -s -k "$RUNNER_TEMP" "$KEYCHAIN_NAME"
        
        # --- MODIFIED ---
        # Give the keychain 2 seconds to process the imported cert
        echo "Waiting for keychain to settle..."
        sleep 2
        # --- END MODIFIED ---

        # Find the certificate's Common Name (CN).
        CERT_CN=$(security find-identity -v "$KEYCHAIN_NAME" | grep "Developer ID Installer" | head -n 1 | sed -E 's/.*"([^"]+)".*/\1/')

        if [ -z "$CERT_CN" ]; then
          echo "::error:: No valid codesigning identity found in keychain."
          security find-identity -v "$KEYCHAIN_NAME" # Print all identities for debugging
          exit 1
        fi
        echo "Using certificate: $CERT_CN"
        echo "CERT_NAME=$CERT_CN" >> $GITHUB_ENV
    
    - name: Execute Custom macOS Build Script
      id: build_pkg
      run: |
        SCRIPT_PATH="build_scripts/build_osx_universal_pkg.sh"
        chmod +x "$SCRIPT_PATH"
        
        set -o pipefail
        
        "$SCRIPT_PATH" \
          ${{ github.ref_name }} \
          ${{ matrix.suffix }} \
          "${{ env.CERT_NAME }}" \
          ${{ matrix.flags }} \
          2>&1 | tee build_log.txt
        
        PKG_PATH=$(grep 'PKG_PATH=' build_log.txt | head -n 1 | sed -n 's/.*PKG_PATH=\(.*\)/\1/p' | tr -d '[:space:]')
        
        if [ -z "$PKG_PATH" ]; then
          echo "::error::Build script finished, but 'PKG_PATH=' was not found in the log."
          exit 1
        fi
        
        echo "PKG_PATH found: $PKG_PATH"
        echo "pkg_path=$PKG_PATH" >> $GITHUB_OUTPUT

    - name: Notarize and Staple PKG
      id: notarize
      env:
        APPLE_NOTARY_USERNAME: ${{ secrets.APPLE_NOTARY_USERNAME }}
        APPLE_NOTARY_PASSWORD: ${{ secrets.APPLE_NOTARY_PASSWORD }}
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      run: |
        PKG_FILE_PATH="${{ steps.build_pkg.outputs.pkg_path }}"
        echo "Submitting $PKG_FILE_PATH for notarization..."
        
        xcrun notarytool submit "$PKG_FILE_PATH" \
          --apple-id "$APPLE_NOTARY_USERNAME" \
          --password "$APPLE_NOTARY_PASSWORD" \
          --team-id "$APPLE_TEAM_ID" \
          --wait
          
        echo "Notarization successful. Stapling ticket..."
        
        xcrun stapler staple "$PKG_FILE_PATH"

    - name: Cleanup Keychain
      if: always() # Always run this, even if previous steps fail
      run: |
        security delete-keychain "$KEYCHAIN_NAME"

    - name: Upload macOS PKG Artifact
      uses: actions/upload-artifact@v4
      with:
        name: superseedr-macos-${{ matrix.suffix }}-universal-${{ github.ref_name }} 
        path: ${{ steps.build_pkg.outputs.pkg_path }}
        
  build_windows:
    name: Build Windows MSI (${{ matrix.suffix }})
    #if: startsWith(github.ref, 'refs/tags/')
    runs-on: windows-latest
    strategy:
      matrix:
        include:
          - suffix: "normal"
            flags: ""
          - suffix: "private"
            flags: "--no-default-features"
    steps:
    - uses: actions/checkout@v5
    - name: Install Rust MSVC Target
      run: rustup target add x86_64-pc-windows-msvc
      
    - name: Install WiX Toolset v3
      run: choco install wixtoolset
      
    - name: Install cargo-wix
      run: cargo install cargo-wix
      
    - name: Build MSI Installer (${{ matrix.suffix }})
      id: build_msi
      run: |
        cargo wix ${{ matrix.flags }}
        
        # Update the path: 'cargo wix' outputs to 'target/wix'
        $MSI_FILE = Get-ChildItem -Path "target/wix" -Filter "*.msi" | Select-Object -First 1
        if ($null -eq $MSI_FILE) { echo "::error:: No .msi file found"; exit 1; }
        echo "msi_path=$($MSI_FILE.FullName)" >> $env:GITHUB_OUTPUT

    - name: Sign MSI Installer (if secret is present)
      # This step will be SKIPPED if the secret is empty
      if: env.WINDOWS_CERT_P12_BASE64 != ''
      id: sign_msi
      env:
        WINDOWS_CERT_P12_BASE64: ${{ secrets.WINDOWS_CERT_P12_BASE64 }}
        WINDOWS_CERT_PASSWORD: ${{ secrets.WINDOWS_CERT_PASSWORD }}
      shell: pwsh
      run: |
        # Decode the certificate
        [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($env:WINDOWS_CERT_P12_BASE64)) | Out-File -FilePath windows.pfx -Encoding OEM
        
        $MSI_PATH = "${{ steps.build_msi.outputs.msi_path }}"
        echo "Signing $MSI_PATH..."
        
        # Find signtool.exe (it's part of the Windows SDK)
        $SIGNTOOL_PATH = (Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits\10\bin" -Filter "signtool.exe" -Recurse | Sort-Object VersionInfo -Descending | Select-Object -First 1).FullName
        if ($null -eq $SIGNTOOL_PATH) {
          echo "::error:: signtool.exe not found."
          exit 1
        }
        echo "Using signtool at $SIGNTOOL_PATH"

        # Sign the file
        & $SIGNTOOL_PATH sign /f "windows.pfx" /p $env:WINDOWS_CERT_PASSWORD /tr http://timestamp.digicert.com /td SHA256 $MSI_PATH
        
        # Clean up
        Remove-Item windows.pfx

    - name: Stage MSI
      shell: pwsh
      run: |
        $VERSION = (Get-Content Cargo.toml | Select-String -Pattern '^version = "(.+)"').Matches.Groups[1].Value
        $MSI_FILE_PATH = "${{ steps.build_msi.outputs.msi_path }}"
        
        if ($SUFFIX -eq "normal") {
            $MSI_NAME = "${{ env.APP_NAME }}_${VERSION}_x64_en-US.msi"
        } else {
            $MSI_NAME = "${{ env.APP_NAME }}-${SUFFIX}_${VERSION}_x64_en-US.msi"
        }
        mkdir staging
        $DEST_PATH = "staging/$MSI_NAME"
        echo "Moving $MSI_FILE_PATH to $DEST_PATH"
        mv $MSI_FILE_PATH $DEST_PATH
        
        # Output the final staged name for the release body
        echo "final_msi_name=$MSI_NAME" >> $env:GITHUB_OUTPUT

    - name: Upload Windows MSI Artifact
      uses: actions/upload-artifact@v4
      with:
        name: superseedr-windows-${{ matrix.suffix }}-${{ github.ref_name }}
        path: staging/*.msi

  release:
    name: Create GitHub Release
    if: startsWith(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    needs: [build_linux, bundle_macos, build_windows] # Correctly waits for only the enabled jobs
    steps:
      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/

      - name: Set Release Version
        run: echo "RELEASE_VERSION=$(echo ${{ github.ref_name }} | sed 's/^v//')" >> $GITHUB_ENV
      
      - name: Create Release and Upload Artifacts
        uses: softprops/action-gh-release@v2
        with:
          name: ${{ github.ref_name }}
          body: |
            ## Standard Builds (Recommended)
            * **macOS Universal:** [superseedr-${{ env.RELEASE_VERSION }}-universal-macos.pkg](https://github.com/Jagalite/superseedr/releases/download/${{ github.ref_name }}/superseedr-${{ env.RELEASE_VERSION }}-universal-macos.pkg)
            * **Linux (Debian):** [superseedr_${{ env.RELEASE_VERSION }}_amd64.deb](https://github.com/Jagalite/superseedr/releases/download/${{ github.ref_name }}/superseedr_${{ env.RELEASE_VERSION }}_amd64.deb)
            * **Windows (MSI):** [superseedr_${{ env.RELEASE_VERSION }}_x64_en-US.msi](https://github.com/Jagalite/superseedr/releases/download/${{ github.ref_name }}/superseedr_${{ env.RELEASE_VERSION }}_x64_en-US.msi)
            ---
            ## Private Builds (Advanced)
            These builds do not contain PEX or DHT in the final binary. Not recommended for normal users unless you have privacy requirements.
            
            * **macOS Universal:** [superseedr-${{ env.RELEASE_VERSION }}-private-universal-macos.pkg](https://github.com/Jagalite/superseedr/releases/download/${{ github.ref_name }}/superseedr-${{ env.RELEASE_VERSION }}-private-universal-macos.pkg)
            * **Linux (Debian):** [superseedr-private_${{ env.RELEASE_VERSION }}_amd64.deb](https://github.com/Jagalite/superseedr/releases/download/${{ github.ref_name }}/superseedr-private_${{ env.RELEASE_VERSION }}_amd64.deb)
            * **Windows (MSI):** [superseedr-private_${{ env.RELEASE_VERSION }}_x64_en-US.msi](https://github.com/Jagalite/superseedr/releases/download/${{ github.ref_name }}/superseedr-private_${{ env.RELEASE_VERSION }}_x64_en-US.msi)
          files: |
            artifacts/superseedr-linux-amd64-debs-${{ github.ref_name }}/*.deb
            artifacts/superseedr-macos-*-universal-${{ github.ref_name }}/*.pkg
            artifacts/superseedr-windows-*-${{ github.ref_name }}/*.msi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
